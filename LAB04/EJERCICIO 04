#include <bits/stdc++.h>
using namespace std;
using namespace std::chrono;

struct Edge {
    int src, dest, weight;
};

struct DisjointSet {
    vector<int> parent, rank;
    DisjointSet(int n) {
        parent.resize(n);
        rank.resize(n, 0);
        for (int i = 0; i < n; i++) parent[i] = i;
    }
    int find(int x) {
        if (x != parent[x]) parent[x] = find(parent[x]);
        return parent[x];
    }
    void unite(int x, int y) {
        int rx = find(x), ry = find(y);
        if (rx == ry) return;
        if (rank[rx] < rank[ry]) parent[rx] = ry;
        else if (rank[rx] > rank[ry]) parent[ry] = rx;
        else { parent[ry] = rx; rank[rx]++; }
    }
};

// Boruvka
int BoruvkaMST(vector<Edge>& edges, int V) {
    DisjointSet ds(V);
    int numTrees = V;
    int MSTweight = 0;

    while (numTrees > 1) {
        vector<int> cheapest(V, -1);

        for (int i = 0; i < edges.size(); i++) {
            int set1 = ds.find(edges[i].src);
            int set2 = ds.find(edges[i].dest);
            if (set1 == set2) continue;
            if (cheapest[set1] == -1 || edges[cheapest[set1]].weight > edges[i].weight)
                cheapest[set1] = i;
            if (cheapest[set2] == -1 || edges[cheapest[set2]].weight > edges[i].weight)
                cheapest[set2] = i;
        }

        for (int i = 0; i < V; i++) {
            if (cheapest[i] != -1) {
                int set1 = ds.find(edges[cheapest[i]].src);
                int set2 = ds.find(edges[cheapest[i]].dest);
                if (set1 == set2) continue;
                ds.unite(set1, set2);
                MSTweight += edges[cheapest[i]].weight;
                numTrees--;
            }
        }
    }
    return MSTweight;
}

// Kruskal
int KruskalMST(vector<Edge>& edges, int V) {
    sort(edges.begin(), edges.end(), [](Edge a, Edge b) {
        return a.weight < b.weight;
    });

    DisjointSet ds(V);
    int MSTweight = 0;

    for (auto &e : edges) {
        int set1 = ds.find(e.src);
        int set2 = ds.find(e.dest);
        if (set1 != set2) {
            MSTweight += e.weight;
            ds.unite(set1, set2);
        }
    }
    return MSTweight;
}

// generador de grafo
vector<Edge> generarGrafoAleatorio(int V, int E) {
    vector<Edge> edges;
    srand(time(0));
    for (int i = 0; i < E; i++) {
        Edge e;
        e.src = rand() % V;
        e.dest = rand() % V;
        e.weight = 1 + rand() % 1000;
        if (e.src != e.dest) edges.push_back(e);
    }
    return edges;
}

// menu
int main() {
    int V = 2000;  // numero de vertices
    int E = 2000;  // numero de aristas
    auto edges = generarGrafoAleatorio(V, E);

    auto start1 = high_resolution_clock::now();
    int boruvkaWeight = BoruvkaMST(edges, V);
    auto stop1 = high_resolution_clock::now();

    auto start2 = high_resolution_clock::now();
    int kruskalWeight = KruskalMST(edges, V);
    auto stop2 = high_resolution_clock::now();

    auto durationBoruvka = 
    duration_cast<milliseconds>(stop1 - start1).count();
    auto durationKruskal = 
    duration_cast<milliseconds>(stop2 - start2).count();

    cout << "Peso total MST (Boruvka): " << boruvkaWeight << endl;
    cout << "Tiempo Boruvka: " << durationBoruvka << " ms" << endl;
    cout << "Peso total MST (Kruskal): " << kruskalWeight << endl;
    cout << "Tiempo Kruskal: " << durationKruskal << " ms" << endl;

    return 0;
}
